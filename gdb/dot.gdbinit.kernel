define xi
x/10i $eip
end
define xs
x/12x $esp
end
define xb
x/12x $ebp
end
define z
ni
x/1i $eip
end
define zs
si
x/1i $eip
end
define xp
printf "      esp: " 
output/x $esp
echo  (
output (((int)$ebp)-(int)$esp)/4-4
printf " words on stack)\n      ebp: " 
output/x $ebp
printf "\n      eip: " 
x/1i $eip
printf "Saved ebp: " 
output/x *(int*)$ebp
printf " (maximum of "  
output ((*(int*)$ebp)-(int)$ebp)/4-4
printf " parameters possible)\nSaved eip: " 
x/1i *(int*)($ebp+4)
printf "\nParm 1 at " 
output/x (int) ($ebp+8)
printf ":    " 
output (char*) *(int*)($ebp+8)
printf "\nParm 2 at " 
output/x (int) ($ebp+12)
printf ":    " 
output (char*) *(int*)($ebp+12)
printf "\nParm 3 at " 
output/x (int) ($ebp+16)
printf ":    " 
output (char*) *(int*)($ebp+16)
printf "\nParm 4 at " 
output/x (int) ($ebp+20)
printf ":    " 
output (char*) *(int*)($ebp+20)
echo \n
end
document xp
Show the register contents and the first four parameter
words of the current frame.
end
define xxp
printf "      esp: " 
output/x $esp
printf "\n      ebp: " 
output/x $ebp
printf "\n      eip: " 
x/1i $eip
printf "Saved ebp: " 
output/x *(int*)$ebp
printf " (maximum of "  
output ((*(int*)$ebp)-(int)$ebp)/4-4
printf " parameters possible)\nSaved eip: " 
x/1i *(int*)($ebp+4)
printf "\nParm  1 at " 
output/x (int) ($ebp+8)
printf ":    " 
output (char*) *(int*)($ebp+8)
printf "\nParm  2 at " 
output/x (int) ($ebp+12)
printf ":    " 
output (char*) *(int*)($ebp+12)
printf "\nParm  3 at " 
output/x (int) ($ebp+16)
printf ":    " 
output (char*) *(int*)($ebp+16)
printf "\nParm  4 at " 
output/x (int) ($ebp+20)
printf ":    " 
output (char*) *(int*)($ebp+20)
printf "\nParm  5 at " 
output/x (int) ($ebp+24)
printf ":    " 
output (char*) *(int*)($ebp+24)
printf "\nParm  6 at " 
output/x (int) ($ebp+28)
printf ":    " 
output (char*) *(int*)($ebp+28)
printf "\nParm  7 at " 
output/x (int) ($ebp+32)
printf ":    " 
output (char*) *(int*)($ebp+32)
printf "\nParm  8 at " 
output/x (int) ($ebp+36)
printf ":    " 
output (char*) *(int*)($ebp+36)
printf "\nParm  9 at " 
output/x (int) ($ebp+40)
printf ":    " 
output (char*) *(int*)($ebp+40)
printf "\nParm 10 at " 
output/x (int) ($ebp+44)
printf ":    " 
output (char*) *(int*)($ebp+44)
echo \n
end
document xxp
Show the register contents and the first ten parameter
words of the current frame.
end
define xp0
x/12x *(int*)$esp
p *(int*)$esp
p (char*)*$esp
end
define xp1
x/12x *(int*)($ebp+4)
p *(int*)($ebp+4)
p (char**)($ebp+4)
end
define xp2
x/12x *(int*)($ebp+8)
p *(int*)($ebp+8)
p *(char**)($ebp+8)
end
define xp3
x/12x *(int*)($ebp+12)
p *(int*)($ebp+12)
p (char**)($ebp+12)
end
define xp4
x/12x *(int*)($ebp+16)
p *(int*)($ebp+16)
p (char**)($ebp+16)
end
document xp0
Show the first parameter of current stack frame in various formats
end
document xp1
Show the second parameter of current stack frame in various formats
end
document xp2
Show the third parameter of current stack frame in various formats
end
document xp3
Show the fourth parameter of current stack frame in various formats
end
document xp4
Show the fifth parameter of current stack frame in various formats
end
define f0
f 0
xp
end
define f1
f 1
xp
end
define f2
f 2
xp
end
define f3
f 3
xp
end
define f4
f 4
xp
end
define f5
f 5
xp
end
document f0
Select stack frame 0 and show assembler-level details
end
document f1
Select stack frame 1 and show assembler-level details
end
document f2
Select stack frame 2 and show assembler-level details
end
document f3
Select stack frame 3 and show assembler-level details
end
document f4
Select stack frame 4 and show assembler-level details
end
document f5
Select stack frame 5 and show assembler-level details
end
document z
Single step 1 instruction (over calls) and show next instruction.
end
document zs
Single step 1 instruction (through calls) and show next instruction.
end
document xi
List the next 10 instructions from the current IP value
end
document xs
Show the last 12 words on stack in hex
end
document xb
Show 12 words starting at current BP value in hex
end
define tr
target remote /dev/cuaa0
end
document tr
Attach to a remote kernel via /dev/cuaa0
end
set output-radix 16
define pname
p (char *)curproc->p_comm
end 
document pname
Print the command name of the current process
end
define bpp
set $bp = (struct buf *) $arg0
    if $bp->b_io.bio_dev
      printf "  Buffer at 0x%x: dev 0x%x  data 0x%x  bcount 0x%x  blkno 0x%x resid 0x%x\n", \
        $bp, \
        $bp->b_io.bio_dev->si_udev, \
        $bp->b_io.bio_data, \
        $bp->b_io.bio_bcount, \
        $bp->b_io.bio_blkno, \
        $bp->b_io.bio_resid
    else
      printf "  Buffer at 0x%x: dev (none) data 0x%x  bcount 0x%x  blkno 0x%x resid 0x%x\n", \
        $bp, \
        $bp->b_io.bio_data, \
        $bp->b_io.bio_bcount, \
        $bp->b_io.bio_blkno, \
        $bp->b_io.bio_resid
    end
    printf "    Command: "
    if $bp->b_io->bio_cmd == 1
      printf "Read, "
    end
    if $bp->b_io->bio_cmd == 2
      printf "Write, "
    end
    if $bp->b_io->bio_cmd == 4
      printf "Delete, "
    end
    if $bp->b_io->bio_cmd == 8
      printf "Format, "
    end
    printf "flags 0x%x: ", $bp->b_flags
    if $bp->b_flags & 0x200
      printf "done "
    end
    if $bp->b_flags & 0x800
      printf "error "
    end
    if $bp->b_flags & 0x40000
      printf "phys "
    end
    printf "\n"
end
define bpl
set $bp = (struct buf *) $arg0
printf "b_proc: "
output $bp->b_proc
printf "\nb_flags:      "
output $bp->b_flags
printf "\nb_qindex:     "
output $bp->b_qindex
printf "\nb_usecount:   "
output $bp->b_usecount
printf "\nb_error:      "
output $bp->b_error
printf "\nb_bufsize:    "
output $bp->b_bufsize
printf "\nb_io.bio_bcount:     "
output $bp->b_io.bio_bcount
printf "\nb_io.bio_resid:      "
output $bp->b_io.bio_resid
printf "\nb_io.bio_dev:        "
output $bp->b_io.bio_dev
printf "\nb_io.bio_data:       "
output $bp->b_io.bio_data
printf "\nb_kvasize:    "
output $bp->b_kvasize
printf "\nb_lblkno:     "
output $bp->b_lblkno
printf "\nb_io.bio_blkno:      "
output $bp->b_io.bio_blkno
printf "\nb_iodone:     "
output $bp->b_iodone
printf "\nb_vp: "
output $bp->b_vp
printf "\nb_dirtyoff:   "
output $bp->b_dirtyoff
printf "\nb_dirtyend:   "
output $bp->b_dirtyend
printf "\nb_generation: "
output $bp->b_generation
printf "\nb_rcred:      "
output $bp->b_rcred
printf "\nb_wcred:      "
output $bp->b_wcred
printf "\nb_validoff:   "
output $bp->b_validoff
printf "\nb_validend:   "
output $bp->b_validend
printf "\nb_pblkno:     "
output $bp->b_pblkno
printf "\nb_saveaddr:   "
output $bp->b_saveaddr
printf "\nb_savekva:    "
output $bp->b_savekva
printf "\nb_driver1:    "
output $bp->b_driver1
printf "\nb_driver2:    "
output $bp->b_driver2
printf "\nb_spc:        "
output $bp->b_spc
printf "\nb_npages:     "
output $bp->b_npages
printf "\n"
end
define bp
bpp bp
end
define bpd
    printf "Buffer data:\n%s", (char *) bp->b_io.bio_data
end
document bpd
Show the contents (char*) of bp->data in the current frame.
end
document bp
Show information about the buffer header pointed to by the
variable bp in the current frame.
end
document bpp
Show summary information about the buffer header (struct bp) pointed
at by the parameter.
end
document bpl
Show detailled information about the buffer header (struct bp) pointed
at by the parameter.
end
document bpl
Show detailled information about the buffer header (struct bp) pointed
at by the local variable bp.
end
define bx
printf "\n b_vnbufs " 
output/x bp->b_vnbufs
printf "\n b_freelist " 
output/x bp->b_freelist
printf "\n b_act " 
output/x bp->b_act
printf "\n b_flags " 
output/x bp->b_flags
printf "\n b_qindex " 
output/x bp->b_qindex
printf "\n b_usecount " 
output/x bp->b_usecount
printf "\n b_error " 
output/x bp->b_error
printf "\n b_bufsize " 
output/x bp->b_bufsize
printf "\n b_io.bio_bcount " 
output/x bp->b_io.bio_bcount
printf "\n b_io.bio_resid " 
output/x bp->b_io.bio_resid
printf "\n b_io.bio_dev " 
output/x bp->b_io.bio_dev
printf "\n b_io.bio_data " 
output/x bp->b_io.bio_data
printf "\n b_kvasize " 
output/x bp->b_kvasize
printf "\n b_io.bio_blkno " 
output/x bp->b_io.bio_blkno
printf "\n b_iodone_chain " 
output/x bp->b_iodone_chain
printf "\n b_vp " 
output/x bp->b_vp
printf "\n b_dirtyoff " 
output/x bp->b_dirtyoff
printf "\n b_validoff " 
output/x bp->b_validoff
echo \n
end
define ddb
set boothowto=0x80000000
s
end
document ddb
Switch back to ddb.
end
define ps
    set $nproc = nprocs
    set $aproc = allproc.lh_first
    set $proc = allproc.lh_first
    printf "  pid    proc    addr    uid  pri ppid  pgrp   flag stat comm         wchan\n"
    while (--$nproc >= 0)
        set $pptr = $proc.p_pptr
        if ($pptr == 0)
           set $pptr = $proc
        end
        if ($proc.p_stat)
            printf "%5d %08x %08x %4d ", \
                   $proc.p_pid, $aproc, \
                   $proc.p_addr, $proc.p_cred->p_ruid
	    if ($proc.p_rtprio.type == 3)
                printf "%3d ", $pptr->p_priority
            else
                printf "%3d*", $proc.p_rtprio.prio
	    end
            printf "%5d %5d  %06x  %d  %-10s   ", \
		   $pptr->p_pid, $proc.p_pgrp->pg_id, $proc.p_flag, $proc.p_stat, \
                   &$proc.p_comm[0]
            if ($proc.p_wchan)
                if ($proc.p_wmesg)
                    printf "%s ", $proc.p_wmesg
                end
                printf "%x", $proc.p_wchan
            end
            printf "\n"
        end
        set $aproc = $proc.p_list.le_next
        if ($aproc == 0 && $nproc > 0)
            set $aproc = zombproc
        end
        set $proc = $aproc
    end
end
document ps
"ps" -- when kernel debugging, type out a ps-like listing of active processes.
end
define pregs
    set $nproc = nprocs
    set $aproc = allproc.lh_first
    set $proc = allproc.lh_first
    while (--$nproc >= 0)
        set $pptr = $proc.p_pptr
        if ($proc->p_pid == $arg0)
	   set $pcba = $pptr->p_addr->u_pcb
	   printf "eax\t%d\t%x", $pcba->pcb_eax, $pcba->pcb_eax
	   printf "ecx\t%d\t%x", $pcba->pcb_ecx, $pcba->pcb_ecx
	   printf "edx\t%d\t%x", $pcba->pcb_edx, $pcba->pcb_edx
	   printf "ebx\t%d\t%x", $pcba->pcb_ebx, $pcba->pcb_ebx
	   printf "esp\t%d\t%x", $pcba->pcb_esp, $pcba->pcb_esp
	   printf "ebp\t%d\t%x", $pcba->pcb_ebp, $pcba->pcb_ebp
	   printf "esi\t%d\t%x", $pcba->pcb_esi, $pcba->pcb_esi
	   printf "edi\t%d\t%x", $pcba->pcb_edi, $pcba->pcb_edi
	   printf "eip\t%d\t%x", $pcba->pcb_eip, $pcba->pcb_eip
	   printf "eflags\t%d\t%x", $pcba->pcb_eflags, $pcba->pcb_eflags
	   printf "cs\t%d\t%x", $pcba->pcb_cs, $pcba->pcb_cs
	   printf "ss\t%d\t%x", $pcba->pcb_ss, $pcba->pcb_ss
	   printf "ds\t%d\t%x", $pcba->pcb_ds, $pcba->pcb_ds
	   printf "es\t%d\t%x", $pcba->pcb_es, $pcba->pcb_es
	   printf "fs\t%d\t%x", $pcba->pcb_fs, $pcba->pcb_fs
	   printf "gs\t%d\t%x", $pcba->pcb_gs, $pcba->pcb_gs
	   x/1i $pcba->pcb_eip
	   set $nproc = 0
        end
        set $aproc = $proc.p_list.le_next
        if ($aproc == 0 && $nproc > 0)
            set $aproc = zombproc
        end
        set $proc = $aproc
    end
end
document pregs
Show some pcb contents of process whose pid is specified.
end
define btr
set $frame = $arg0
set $fno = 0
while (*(int *) $frame > 0xc0000000)
  set $myebp = *(int *) $frame
  set $myeip = *(int *) ($frame + 4)
  printf " frame %d at %p: ebp %8x, eip ", $fno, $frame, $myebp
  x/1i $myeip
  set $frame = $myebp
  set $fno = $fno + 1
end
end
document btr
Show a backtrace from the ebp address specified.  This can be used to
get a backtrace from any stack resident in memory.
end
define btp
    set $nproc = nprocs
    set $aproc = allproc.lh_first
    set $proc = allproc.lh_first
    while (--$nproc >= 0)
        if ($proc->p_pid == $arg0)
	   btr $proc->p_addr->u_pcb->pcb_ebp
	   set $nproc = 0
	else
           set $aproc = $proc.p_list.le_next
           if ($aproc == 0 && $nproc > 0)
              set $aproc = zombproc
           end
           set $proc = $aproc
        end
   end
end
document btp
Show a backtrace for the process whose pid is specified as a parameter.
end
define btpa
    set $nproc = nprocs
    set $aproc = allproc.lh_first
    set $proc = allproc.lh_first
    printf "  pid    proc    addr   uid  ppid  pgrp   flag stat comm         wchan\n"
    while (--$nproc >= 0)
        set $pptr = $proc.p_pptr
        if ($pptr == 0)
           set $pptr = $proc
        end
        if ($proc.p_stat)
            printf "%5d %08x %08x %4d %5d %5d  %06x %d  %-10s   ", \
                   $proc.p_pid, $aproc, \
                   $proc.p_addr, $proc.p_cred->p_ruid, $pptr->p_pid, \
                   $proc.p_pgrp->pg_id, $proc.p_flag, $proc.p_stat, \
                   &$proc.p_comm[0]
            if ($proc.p_wchan)
                if ($proc.p_wmesg)
                    printf "%s ", $proc.p_wmesg
                end
                printf "%x", $proc.p_wchan
            end
            printf "\n"
	   if ($proc->p_flag & 4)
	      btr $proc->p_addr->u_pcb->pcb_ebp
	   else
              echo (not loaded)\n
	   end
        end
        set $aproc = $proc.p_list.le_next
        if ($aproc == 0 && $nproc > 0)
            set $aproc = zombproc
        end
        set $proc = $aproc
    end
end
document btpa
Show backtraces for all processes in the system.
end
define btpp
  if ($myvectorproc->p_flag & 4)
    btr $myvectorproc->p_addr->u_pcb->pcb_ebp
  else
    echo (not loaded)\n
  end
end
document btpp
Show a backtrace for the process previously selected with 'defproc'.
end
define defproc
    set $nproc = nprocs
    set $aproc = allproc.lh_first
    set $proc = allproc.lh_first
    while (--$nproc >= 0)
        if ($proc->p_pid == $arg0)
	   set $pptr = $proc.p_pptr
           if ($pptr == 0)
              set $pptr = $proc
           end
	   set $myvectorproc = $proc
           if ($proc.p_stat)
               printf "%5d %08x %08x %4d %5d %5d  %06x %d  %-10s   ", \
                      $proc.p_pid, $aproc, \
                      $proc.p_addr, $proc.p_cred->p_ruid, $pptr->p_pid, \
                     $proc.p_pgrp->pg_id, $proc.p_flag, $proc.p_stat, \
                     &$proc.p_comm[0]
               if ($proc.p_wchan)
                   if ($proc.p_wmesg)
                       printf "%s ", $proc.p_wmesg
                  end
                  printf "%x", $proc.p_wchan
               end
               printf "\n"
	      end
	   btpp
	   set $nproc = 0
	else
           set $proc = $proc.p_list.le_next
        end
   end
end
document defproc
Specify a process for btpp and fr commands.
end
define fr
set $fno = 0
set $searching = 1
if ($myvectorproc->p_flag & 4)
  set $frame = $myvectorproc->p_addr->u_pcb->pcb_ebp
  while (($searching == 1) && (*(int *) $frame > 0xc0000000))
    set $myebp = *(int *) $frame
    set $myeip = *(int *) ($frame + 4)
    if ($fno == $arg0)
      printf " frame %d at %p: ebp %8x, eip ", $fno, $frame, $myebp
      x/1i $myeip
      printf "Called from %8x, stack frame at %8x\n", *(int *) ($myebp+4), *(int *) $myebp
      printf "last 20 local variables:\n"
      x/20x ($myebp-80)
      printf "call parameters:\n"
      x/8x ($myebp+8)
      set $searching = 0
    else
      set $frame = $myebp
      set $fno = $fno + 1
    end
  end
  if ($searching == 1)
    echo frame not found\n
  end
else
  printf "process %d is not loaded in memory\n", $myvectorproc->p_pid
end
end
document fr
Show the frame of the stack of the process previously selected with 'defproc'.
end
set height 70
set width 120
define vdev
if (vp->v_type == VBLK)
  p *vp->v_un.vu_spec.vu_specinfo
  printf "numoutput: %d\n", vp->v_numoutput
else
  echo "Not a block device"
end
end
document vdev
Show some information of the vnode pointed to by the local variable vp.
end
define y
echo Check your .gdbinit, it contains a y command\n
end
define kldstat
   set $file = linker_files.tqh_first
   printf "Id Refs Address    Size     Name\n"
   while ($file != 0)
     printf "%2d %4d 0x%8x %8x %s\n",   \
	$file->id, 			\
	$file->refs,			\
	$file->address,			\
	$file->size,			\
	$file->filename
     set $file = $file->link.tqe_next
   end
end
document kldstat
Equivalent of the kldstat(9) command, without options.
end
define msgbuf
printf "%s", msgbufp->msg_ptr
end
document msgbuf
Print the system message buffer (dmesg).  This can take a long time due to the time it takes to transmit the data across a serial line.
end
define icnt
set $irq = 0
set $mask = imen
while ($irq < 23)
  if ($mask & 1)
    printf "%d*\t", *intr_countp [$irq]
  else
    printf "%d\t", *intr_countp [$irq]
  end
  if (($irq & 7) == 7)
    printf "\n"
  end
  set $irq = $irq + 1
  set $mask = $mask >> 1
  end
printf "\nimen: %x\n", imen
end
document icnt
Print the interrupt counts for the first 16 interrupts
end
set $last=75
set $seg=43
 
# kmem_hdr
define kmemhdr
        printf "\tINUSE\tCALLS\tMEMUSED\tLIMBLK\tMAPBLK\tMAXUSED\t\tLIMIT\n"
end
 
# pkmem <ptr>
define pkmem
        set $kp=(struct kmemstats *)$arg0
        set $n = (struct kmemstats *)$kp - (struct kmemstats *)kmemstats
        printf "%d:\t%d\t%d", $n, $kp->ks_inuse, $kp->ks_calls
        printf "\t0x%x\t%d", $kp->ks_memuse, $kp->ks_limblocks
        printf "\t%d\t0x%x\t\t%d\n", $kp->ks_mapblocks, $kp->ks_maxused, $kp->ks_limit
end
 
define kmemdump
        set $kp=(struct kmemstats *)(kmemstats + $arg0)
        kmemhdr
        pkmem $kp
end

define kdumpall
        set $i=0

        kmemhdr
        set $kp = (struct kmemstats *)kmemstats
        while ($i < $last)
                pkmem $kp
                set $kp++
                set $i++
        end
end
define ktr
        set $idx = ktr_idx - 1
        set $last = ktr_idx
        if ($idx == -1)
                set $idx = ktr_entries - 1
        end
        while ($idx != $last)
                set $kent = &ktr_buf[$idx]
                set $time = $kent->ktr_tv.tv_nsec
                set $ts = $kent->ktr_tv.tv_sec
                set $desc = $kent->ktr_desc
                printf "%3d %d:%9.9d ", $idx, $ts, $time
#               printf $desc, $kent->ktr_parm1, $kent->ktr_parm2, $kent->ktr_parm3, $kent->ktr_parm4, $kent->ktr_parm5
                if (ktr_extend)
                        printf "cpu%d %s.%d\t%s\n", $kent->ktr_cpu, $kent->ktr_filename, $kent->ktr_line, $kent->ktr_desc
                else
                        printf "%s %p %p %p %p %p\n", $desc, $kent->ktr_parm1, $kent->ktr_parm2, $kent->ktr_parm3, $kent->ktr_parm4, $kent->ktr_parm5
                end
                set $idx = $idx - 1
                if ($idx == -1)
                	set $idx = ktr_entries - 1
                end
        end
end
define ktrc
        set $idx = ktr_idx - 1
        set $last = ktr_idx
        if ($idx == -1)
                set $idx = ktr_entries - 1
        end
        while ($idx != $last)
		if (ktr_buf[$idx]->ktr_cpu == $arg0)
                	set $kent = &ktr_buf[$idx]
                	set $time = $kent->ktr_tv.tv_nsec
                	set $ts = $kent->ktr_tv.tv_sec
                	set $desc = $kent->ktr_desc
                	printf "%3d %d:%9.9d ", $idx, $ts, $time
                	if (ktr_extend)
                        	printf "cpu%d %s.%d\t%s\n", $kent->ktr_cpu, $kent->ktr_filename, $kent->ktr_line, $kent->ktr_desc
                	else
                        	printf "%s %p %p %p %p %p\n", $desc, $kent->ktr_parm1, $kent->ktr_parm2, $kent->ktr_parm3, $kent->ktr_parm4, $kent->ktr_parm5
			end
                end
                set $idx = $idx - 1
                if ($idx == -1)
                	set $idx = ktr_entries - 1
                end
        end
end
define tc
	set $tc = timecounter
	printf "Timecounter: %s\n", $tc->tc_name
	set $i = 0
	while ($i == 0 || $tc != timecounter)
		printf "tc%d: tv: %ld:%ld raw: %ld:%ld\n", $i, $tc->tc_microtime->tv_sec, $tc->tc_microtime->tv_usec, $tc->tc_offset_sec, $tc->tc_offset_micro
		set $tc = $tc->tc_other
		set $i = $i + 1
	end
end
