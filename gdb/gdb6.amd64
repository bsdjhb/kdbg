# $Id$
# amd64-specific kernel macros

set $DMAP_MIN_ADDRESS = 0xffffff0000000000
set $DMAP_MAX_ADDRESS = 0xffffff8000000000
set $PG_PDE_PAT = 0x1000
set $PG_PTE_PAT = 0x80
set $PG_PS = 0x80
set $PG_NC_PCD = 0x10
set $PG_NC_PWT = 0x8
set $PG_V = 0x1
set $PG_PS_FRAME = 0xfffffffe00000
set $PG_FRAME = 0xffffffffff000
set $PDMAP = 0xffff804000000000
set $PTMAP = 0xffff800000000000
set $PDRMASK = 0x1fffff
set $PAGE_MASK = 0xfff
set $PAGE_SIZE = 0x1000
set $PDE_MASK = 0x7ffffff
set $PTE_MASK = 0xfffffffff
set $PML4SHIFT = 0x27
set $PDPSHIFT = 0x1e
set $PDRSHIFT = 0x15
set $PAGE_SHIFT = 0xc
set $NPML4EPGSHIFT = 0x9
set $NPDPEPGSHIFT = 0x9
set $NPDEPGSHIFT = 0x9
set $NPTEPGSHIFT = 0x9

set $MC_STATUS_ADDRV = 0x0400000000000000
set $MC_STATUS_MISCV = 0x0800000000000000

define pmap_pml4e
    set $_pm = (struct pmap *)$arg0
    set $_va = (long)$arg1
    if ($_pm == 0)
        set $_pm = &kernel_pmap_store
    end
    set $arg2 = $_pm->pm_pml4[(($_va >> $PML4SHIFT) & (((long)1 << $NPML4EPGSHIFT) - 1))]
end

document pmap_pml4e
Given a pmap and virtual address, lookup the value of the pml4 entry and
store it in the 3rd arg.
end

define phys_to_dmap
    set $arg1 = (long)$arg0 | $DMAP_MIN_ADDRESS
end

document phys_to_dmap
Given a physical address, return the corresponding virtual address in the
direct map in the 2nd arg.
end

define pmap_pdpe
    pmap_pml4e $arg0 $arg1 $_pml4e
    if (!($_pml4e & $PG_V))
	set $arg2 = 0
    else
	set $_va = (long)$arg1
	set $_temp = (long)$_pml4e & $PG_FRAME
	phys_to_dmap $_temp $__pdpe
	set $arg2 = ((pdp_entry_t *)$__pdpe)[(($_va >> $PDPSHIFT) & \
	    (((long)1 << $NPDPEPGSHIFT) - 1))]
    end
end

document pmap_pdpe
Given a pmap and virtual address, lookup the value of the pdp entry and
store it in the 3rd arg.
end

define pmap_pde
    pmap_pdpe $arg0 $arg1 $_pdpe
    if (!($_pdpe & $PG_V))
	set $arg2 = 0
    else
	set $_va = (long)$arg1
	set $_temp = (long)$_pdpe & $PG_FRAME
	phys_to_dmap $_temp $__pde
	set $arg2 = ((pd_entry_t *)$__pde)[(($_va >> $PDRSHIFT) & \
	    (((long)1 << $NPDEPGSHIFT) - 1))]
    end
end

document pmap_pde
Given a pmap and virtual address, lookup the value of the page directory entry
and store it in the 3rd arg.
end

define pmap_pte
    pmap_pde $arg0 $arg1 $_pde
    if (!($_pde & $PG_V))
	set $arg2 = 0
    else
        if ($_pde & $PG_PS)
	    set $arg2 = $_pde
	else
	    set $_va = (long)$arg1
	    set $_temp = (long)$_pde & $PG_FRAME
	    phys_to_dmap $_temp $__pte
	    set $arg2 = ((pt_entry_t *)$__pte)[(($_va >> $PAGE_SHIFT) & \
		(((long)1 << $NPTEPGSHIFT) - 1))]
        end
    end
end

document pmap_pte
Given a pmap and virtual address, lookup the value of the page table entry
and store it in the 3rd arg.
end

define pmap_kextract
    set $va = (long)$arg0
    set $pa = -1
    if ($va >= $DMAP_MIN_ADDRESS && $va <= $DMAP_MAX_ADDRESS)
	set $pa = $va - $DMAP_MIN_ADDRESS
    else
	pmap_pde 0 $arg0 $pde
	if ($pde & $PG_V)
	    if ($pde & $PG_PS)
		set $pa = ($pde & $PG_PS_FRAME) | ($va & $PDRMASK)
	    else
		pmap_pte 0 $arg0 $pte
		if ($pte & $PG_V)
		    set $pa = ($pte & $PG_FRAME) | \
			($va & $PAGE_MASK)
		end
	    end
	end
    end
    if ($pa == -1)
	printf "Invalid, unmapped, or unfaulted address\n"
    else
	printf "KVA %p => 0x%lx\n", $va, $pa
    end
end

document pmap_kextract
Map a kernel virtual address to a physical address on amd64.
'kextract' in kgdb is more portable.
end

define pmap_extract
    set $va = (long)$arg1
    set $pa = -1
    pmap_pde $arg0 $arg1 $pde
    if ($pde & $PG_V)
	if ($pde & $PG_PS)
	    set $pa = ($pde & $PG_PS_FRAME) | ($va & $PDRMASK)
	else
	    pmap_pte $arg0 $arg1 $pte
	    if ($pte & $PG_V)
		set $pa = ($pte & $PG_FRAME) | ($va & $PAGE_MASK)
	    end
	end
    end
    if ($pa == -1)
	printf "Invalid, unmapped, or unfaulted address\n"
    else
	printf "VA %p => 0x%lx\n", $va, $pa
    end
end

document pmap_extract
Map a user virtual address to a physical address on amd64.
end

define rawpte
    set $va = (long)$arg1
    set $pte = 0
    pmap_pde $arg0 $arg1 $pde
    if (($pde & ($PG_V | $PG_PS)) == $PG_V)
	pmap_pte $arg0 $arg1 $pte
    end
    if ($pte == 0)
	printf "VA %p => PDE 0x%lx\n", $va, $pde
	set $_pat = $pde & ($PG_PDE_PAT | $PG_NC_PCD | $PG_NC_PWT)
    else
	printf "VA %p => PTE 0x%lx\n", $va, $pte
	set $_pat = $pte & ($PG_PTE_PAT | $PG_NC_PCD | $PG_NC_PWT)
    end
    printf "PAT bits: 0x%lx\n", $_pat
end

document rawpte
Display the raw PTE/PDE for a given virtual address.
end
    
define pmap_pages
    set $pm = (struct pmap *)$arg0
    set $sva = $arg1
    set $eva = $arg2
    set $pv = $pm->pm_pvlist.tqh_first
    while ($pv != 0)
	if ($pv->pv_va >= $sva && $pv->pv_va <= $eva)
	    printf "%08llx: page XXX\n", $pv->pv_va
	end
	set $pv = $pv->pv_plist.tqe_next
    end
end

document pmap_pages
Given a pmap, a starting virtual address, and an ending virtual address,
list all the pages that fall in the range.
end

# Do a backtrace given %rip and %rbp as args
define bt
    set $_rip = $arg0
    set $_rbp = $arg1
    set $i = 0
    while ($_rbp != 0 || $_rip != 0)
	printf "%2d: pc ", $i
	if ($_rip != 0)
		x/1i $_rip
	else
		printf "\n"
	end
	if ($_rbp == 0)
	    set $_rip = 0
	else
	    set $fr = (struct amd64_frame *)$_rbp
	    set $_rbp = $fr->f_frame
	    set $_rip = $fr->f_retaddr
	    set $i = $i + 1
	end
    end
end

document bt
Given values for %rip and %rbp, perform a manual backtrace.
end

define btf
    bt $arg0.tf_rip $arg0.tf_rbp
end

document btf
Do a manual backtrace from a specified trapframe.
end

define irqs
    set $e = event_list->tqh_first
    while ($e != 0)
	if ($e->ie_source != 0 && $e->ie_handlers.tqh_first != 0)
	    set $src = (struct intsrc *)$e->ie_source
	    if ($src->is_pic->pic_enable_source == &ioapic_enable_source)
		set $_cpu = ((struct ioapic_intsrc *)$src)->io_cpu
	    else
		if ($src->is_pic->pic_enable_source == &msi_enable_source)
		    set $_cpu = ((struct msi_intsrc *)$src)->msi_cpu
		else
		    set $_cpu = 0
		end
	    end
	    printf "CPU %d: %s\n", $_cpu, $e->ie_fullname
	end
	set $e = $e->ie_list.tqe_next
    end
end

document irqs
Dump list of IRQs with associated CPU.
end

define mca_log_old
    printf "MCA: bank %d, status 0x%016llx\n", $arg0.mr_bank, $arg0.mr_status
    printf "MCA: CPU %d xxxx\n", $arg0.mr_apic_id
    if ($arg0.mr_status & $MC_STATUS_ADDRV)
	printf "MCA: Address 0x%llx\n", $arg0.mr_addr
    end
    if ($arg0.mr_status & $MC_STATUS_MISCV)
	printf "MCA: Misc 0x%llx\n", $arg0.mr_misc
    end
end

define mca_log
    printf "MCA: Bank %d, Status 0x%016llx\n", $arg0.mr_bank, $arg0.mr_status
    printf "MCA: Global Cap 0x%016llx, Status 0x%016llx\n", $arg0.mr_mcg_cap, \
	$arg0.mr_mcg_status
    printf "MCA: Vendor \"%s\", ID 0x%x, APIC ID %d\n", cpu_vendor, \
	$arg0.mr_cpu_id, $arg0.mr_apic_id
    printf "MCA: CPU %d xxxx\n", $arg0.mr_cpu
    if ($arg0.mr_status & $MC_STATUS_ADDRV)
	printf "MCA: Address 0x%llx\n", $arg0.mr_addr
    end
    if ($arg0.mr_status & $MC_STATUS_MISCV)
	printf "MCA: Misc 0x%llx\n", $arg0.mr_misc
    end
end

define mca
   set $mr = mca_records.stqh_first
   while ($mr != 0)
	if (sizeof($mr->rec) == 40)
	    mca_log_old $mr->rec
	else
	    mca_log $mr->rec
	end
	set $mr = $mr->link.stqe_next
   end
end

document mca
Display machine check records in dmesg format for mcelog parsing.
end

directory /sys/amd64/include
directory /sys/amd64/compile/GENERIC
